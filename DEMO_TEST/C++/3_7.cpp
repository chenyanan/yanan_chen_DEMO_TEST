//
//  3_7.cpp
//  123
//
//  Created by chenyanan on 2017/4/21.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>
#include "hierarchical_mutex.h"

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//3.2.5 避免死锁的进一步指南

//死锁并不仅仅产生于锁定，虽然这是最常见的诱因，你可以通过两个线程来制造死锁，不用锁定，只需令每个线程在std::thread对象上为另一个线程调用join()，在这种情况下，两个线程都无法取得进展，因为正等着另一个线程完成，就像孩子们争夺他们的玩具，这种简单的循环可以发生在任何地方，一个线程等待另一个线程执行一些动作而另一个线程同时又在等待第一个线程，而且这不仅限于两个线程，三个或更多线程的循环也会导致死锁，避免死锁的准则全都可以归结为一个思路，如果又另外一个线程有可能在等待你，那你就别等他，这个独特的准则为识别和消除别的线程等待你的可能性提供了方法

//1.避免嵌套锁
//第一个思路是最简单的，如果你已经持有一个锁，就别再获取锁，如果你坚持这个准则，光凭使用锁是不可能导致死锁的，因为每个线程仅持有一个锁，你仍然会从其他事情(像是线程相互等待)中得到死锁，但是互斥元锁定可能死锁最常见的诱因，如果需要获取多个锁，为了避免死锁，就以std::lock的单个动作来实行

//2.在持有锁时，避免调用用户提供的代码
//这是前面一条准则的简单后续，因为代码是用户提供的，你不知道它会做什么，它可能做包括获取锁在内的任何事情，如果你在持有锁时调用用户提供的代码，并且这段代码获取一个锁，你就违反了避免嵌套锁的准则，可能导致死锁，有时候这是无法避免的，如果你在编写泛型代码，如3.2.3节中的堆栈，在参数类型上的每一个操作都是用户提供的代码，在这种情况下，你需要新的准则

//3.以固定顺序获取锁
//如果你绝对需要获取两个或更多的锁，并且不能以std::lock的单个操作取得，次优的做法是在每个线程中以相同的顺序获取他们，我在3.2.4接种曾谈及此点，是作为在获取两个互斥元时避免死锁的方法，关键是要以一种在线程间相一致的方法来定义其顺序，在某些情况下，这是相对简单的，例如看一看3.2.3节中的堆栈，互斥元在每个栈实例的内部，但对于储存在栈中的数据项的操作，则需要调用用户提供的代码，然而，你可以添加约束，对于存储在栈中的数据项的操作，都不应对栈本身进行任何操作，这样就增加了栈的使用者的负担，但是将数据存储在一个容器中来访问该容器是很罕见的，并且一旦发生就会十分明显，因此这并不是一个很难承受的负担

//在别的情况下，可能就不那么直观，就像在3.2.4节中你所看到的交换操作那样，至少在这种情况下，你可以同时锁定这些互斥元，但并不总是可能的，如果你回顾一下3.1节中链表的例子，你会看到一种保护链表的可能性，就是让每个节点都有一个互斥元，然后为了访问这个链表，线程必须获取他们感兴趣的每个节点上的锁，要删除的结点以及它两边的结点，因为他们全都要以某种方式进行修改，同样地为了遍历链表，线程在获取序列中下一个结点上的锁的时候，必须保持当前节点上的锁，以确保指向下一结点的指针在此期间不被修改，一旦获取到下一个结点上的锁，就可以释放前面结点上的锁，因为它已经没用了

//这种逐节向上的锁定方式允许多线程访问链表，前提是每个线程访问不同的节点，然而为了避免死锁，必须始终以相同的顺序锁定结点，如果两个线程试图用逐节锁定的方式以相反的顺序便利链表，它们就会在链表中间产生相互死锁，如果结点A和B在链表中相邻，一个方向上的线程会试图保持锁定结点A，并尝试获取结点B上的锁，而另一个方向上的线程会保持锁定结点B，并且尝试获得结点A上的锁，死锁的典型情况

//同样的，当删除位于结点A和C之间的结点B时，如果该线程在获取结点A和C上的锁之前获取B上的锁，他就有可能与遍历链表的线程产生死锁，这样的线程会试图首先锁定A和C(取决于遍历的方向)，但是它接下来会发现无法获得结点B上的锁，因为正在进行删除操作的线程持有了结点B上的锁，并试图获得结点A和C上的锁

//在这里防止死锁的一个办法是定义遍历的顺序，让线程必须始终在锁定B之前锁定A，在锁定C之前锁定B，该方法以禁止反向便利为代价来消除产生死锁的可能，对于其他数据结构，常常会建立类似的约定

//4.使用层次锁
//虽然这实际上是定义锁定顺序的一个特例，但锁层次能够提供一种方法，来检查在运行时是否遵循了约定，其思路是将应用程序分层，并且确认所有能够在任意给定的次鞥及上被锁定的互斥元，当代码试图锁定一个互斥元时，如果它在较低层已经持有锁定，那么就不允许它锁定该互斥元，通过给每一个互斥元分配层号，并记录下每个线程都锁定了哪些互斥元，你就可以在运行时进行检查了，清单3.7列出了两个线程使用层次互斥元的例子

//清单3.7 使用锁层次来避免死锁

hierarchical_mutex high_level_mutex(10000);   //①
hierarchical_mutex low_level_mutex(5000);   //②

static int do_low_level_stuff() { return 0; }

static int low_level_func()
{
    std::lock_guard<hierarchical_mutex> lk(low_level_mutex);   //③
    return do_low_level_stuff();
}

static void high_level_stuff(int some_param) {}

static void high_level_func()
{
    std::lock_guard<hierarchical_mutex> lk(high_level_mutex);   //④
    high_level_stuff(low_level_func());   //⑤
}

static void thread_a()   //⑥
{
    high_level_func();
}

hierarchical_mutex low_level_mutex(100);   //⑦
static void do_other_stuff() {}

static void other_func()
{
    high_level_func();   //⑧
    do_other_stuff();
}

static void thread_b()   //⑨
{
    std::lock_guard<hierarchical_mutex> lk(other_mutex);   //⑩
    other_func();
}

//thread_a()⑥遵守了规则，所以它运行良好，另一方面，thread_b()⑨无视了规则，因此将在运行时失败，thread_a()调用high_level_func()，它锁定了high_level_mutex④(具有层次值10000)并接着使用这个锁定了的互斥元调用low_level_func()⑤，以获得high_level_stuff()的参数，low_level_func()接着锁定了low_level_mutex③，但是没有关系，因为该互斥元具有较低的层次值5000②

//在另一方面thread_b()却不妥，刚开始，它锁定了other_mutex⑩，它具有的层次值仅为100⑦，这意味着它应该是保护着超低级别的数据，当other_func()调用high_level_func()⑧时，就会违反层次，high_level_func()试图获取值为10000的high_level_mutex,大大超过100的当前层次值，因此hierarchical_mutex可能通过引发异常或终止程序来报错，层次互斥元之间的死锁是不可能出现的，因为互斥元本身实行了锁定顺序，这还意味着如果两个锁在层次中处于相同级别，你就不能同时持有它们，因此逐节锁定的方案要求链条中的每个互斥元具有比前一个互斥元更低的层次值，在某些情况下，这可能是不切实际的

//这个例子也展现了另外一点，带有用户定义的互斥元类型的std::lock_guard<>模板的使用，hierarchical_mutex不是标准的一部分，但易于编写，清单3.8中展示了一个简单的实现，即便它是个用户定义的类型，但是可以用于std::lock_guard<>这是因为它实现了满足互斥元概念所需要的三个成员函数:lock(),unlock(),try_lock(),你还没有见过直接使用try_lock(),但是它相当简单的，如果互斥元上的锁已被另一个线程持有，则返回false,而非一直等到调用线程可以获取该互斥元上的锁，try_lock()也可以在std::lock()内部，作为避免死锁算法的一部分来使用

//清单3.8 简单的分层次互斥元

//5.将这些设计准则扩展到锁之外
//正如我在本节开始时提到的，死锁不只是出现于锁定中，它可以发生在任何可以导致循环等待的同步结构中，因此，扩展上面所述的准则来涵盖那些情况也是值得的，举个例子，正如你应该尽量避免获取嵌套锁那样，在持有锁时等待第一个线程是坏主意，因为该长城可能需要获取这个锁以继续运行，类似地，如果你正要等待一个线程完成，指定线程层次结构可能也是值得的，这样线程就只需要等待底层次上的线程，一个简单的做到这一点的方法，就是确保你的线程在启动他们的同一个函数中被结合，就像3.1.2节和3.3节中所描述的那样

//一旦你设计了代码来避免死锁，std::lock()和std::lock_guard涵盖了大多数简单锁定的情况，但有时却需要更大的灵活性，在那种情况下，标准库提供了std::unique_lock模板，在与std::lock_guard类似，std::unique_lock是在互斥元类型上进行参数化的类模板，并且它提供了与std::lock_guard相同的RAII风格锁管理，但是更加灵活

#pragma clang diagnostic pop
