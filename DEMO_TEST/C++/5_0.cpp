//
//  5_0.cpp
//  123
//
//  Created by chenyanan on 2017/5/4.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//第5章 C++内存模型和原子操作类型上操作
//C++11内存模型的详情
//由C++标准库提供的原子类型
//这些类型上可用的操作
//如何使用那些操作提供线程间的同步

//C++11标准中最重要的特性之一，是大多数程序员甚至都不会关注的东西，他并不是新的语法特性，也不是新的类库功能，而是新的多线程感知内存模型，若是没有内存模型来严格定义基本构造模块如何工作，我所介绍的功能就不可能可靠地工作，当然，大多数程序员没有注意到它是有原因的，如果使用互斥元来保护数据，以及条件变量或者future作为事件信号，它们为何工作的细节就不重要了，仅当你开始尝试"接近机器"时，内存模型的精确细节才重要

//无论其他语言如何，C++是一门系统编程语言，标准委员会的目标之一，是不再需要一个比C++更低级的语言，应该在C++里为程序员提供足够的灵活性，在做任何他们需要的事情时不会被语言挡在路中间，并且在提出需求时允许它们"接近机器"，原子类型和操作正式要允许这一点，提供了可通常减至一或两个CPU指令的低阶同步操作的功能

//在本章中，我将从阐述内存模型的基础开始，接着转到原子类型和操作，并最终介绍可用于原子类型上操作的多种同步类型，这是相当复杂的，除非你打算使用原子操作编写代码以实现同步(比如第7章中的无锁数据结构)，否则无需知道这些细节

//让我们来放松，来看看内存模型的基础

//5.1 内存模型基础

//内存模型包括两个方面，基本结构方面，这与事务是如何放置在内存中的有关，然后是并发方面，结构方面对于并发是很重要的，尤其从低阶原子操作中来看，因此我将从这里开始，在C++中，一切都是关于对象和内存位置

//5.1.1 对象和内存位置

//C++程序中的所有数据均是由对象组成的，这并不是说你可以创建一个派生自int的新类，或是基本类型具有成员函数，或者当人们谈及如Smalltalk或Ruby这样的语言，说"一切都是对象"时安之的任何其他结果，这只是一句关于C++中数据的构造快的一种陈述，C++标准定义对象为"存储区域",尽管它会为这些对象分配属性，如它们的类型和生存期

//其中一些对象是简单基本类型的值，如int或float，而另一些则是用户定义类的实例，有些对象(例如数组，派生类的实例和具有非静态数据成员类的实例)具有子对象，但其他的则没有

//无论什么类型，对象均被存储于一个或多个内存位置中，每个这样的内存位置要么是一个标量类型的对象(或子对象)，比如unsigned short或my_class*，要么是相邻位域的序列，如果使用位域，有非常重要的一点必须注意:虽然相邻的位域是不同的对象，但它们仍然算作相同的内存位置，图5.1表示了一个struct如何划分为对象和内存位置

//首先，整个struct是一个对象，它由几个子对象组成，各子对象对应每个数据成员，位域bf1和bf2共享一个内存位置，而std::string对象在内部由几个内存位置组成，但是其余的每个成员都有自己的内存位置，注意零长度的位域bf3是如何将bf4分割进它自己的内存位置的

//可以从中汲取四个要点

//每个变量都是一个对象，包括其他对象的成员
//每个对象占据至少一个内存位置
//如int或char这样的基本类型的变量恰好一个内存位置，无论其大小，即便他们相邻或是数组的一部分
//相邻的位域是相同内存位置的一部分

//我可以肯定你在怀疑这与并发有什么关系，那么让我们来看一看

struct my_data
{
    int i;
    double b;
    unsigned bf1 : 10;
    int bf2 : 25;
    int     : 0;
    int bf4 : 9;
    int i2;
    char c1, c2;
    std::string s;
};

// i
// d
// bf1 bf2
// bf3
// bf4
// i2
// c1
// c2
// s

//5.1.2 对象、内存位置以及并发

//好了，这里是对于C++中多线程应用程序至关重要的部分，所有东西都取决于这些内存位置，如果两个线程访问不同的内存为止，是没有问题的，一切工作正常，另一方面，如果两个线程访问相同的内存为止，是没有问题的，一切正常工作，另一方面，如果两个线程访问相同的内存为止，那么你就得小心了，如果线程都没有在更新该内存为止，没问题，制度数据不需要进行保护或同步，如果任意一个线程正修改数据，就会有竞争条件的可能，如第3张所述

//为了变竞争条件，在这两个线程的访问中间，就必须有一个强制的顺序，确保有一个确定顺序的方法之一，是使用如第3章中所述的互斥元，如果同一个互斥元在两个访问之前被锁定，则每次只有一个想成可以访问该内存位置，即有一个必然发生在另一个之前，另一种方法是在相同的或是其他的内存位置使用原子(atomic)操作的同步特性(参见5.2节对原子操作的定义)，在两个线程的访问之间强加一个顺序，用原子操作来强制顺序描述与5.3节，如果多余两个线程访问同一个内存位置，则每一对访问都必须就有明确的顺序

//如果来自独立线程的两个对同意内存位置的访问没有强制顺序，其中一个或两个访问不是原子的，且一个或两个是写操作，那么这就是数据竞争并导致未定义行为

//这个陈述是至关重要的，未定义行为是C++最令人不爽的状况之一，根据语言标准，一旦应用程序包含未定义行为，那么一切都很难说，整个应用程序的行为都是未定义的，它能干出任何事情来，我所知道的一个情况是，某个未定义行为的实例导致某人的监视器着火了，虽然这不大可能发生在你身上，但数据竞争绝对是一个严重的错误，且应该不惜一切代价来避免

//在该陈述中，还有另外一个很重要的点，可以通过使用原子操作来访问橘右京这个的内存位置，来避免不确定行为，这并不阻止竞争本身，原子操作所接触的内存位置首先扔是未指定的，但是却能够将程序待会确定行为的领域

//在学习原子操作前，还有一个对了解对象与内存位置很重要的概念，修改顺序

//5.1.3 修改顺序

//C++程序中每个对象，都具有一个确定的修改顺序，它是由来自程序中的所有线程的对该对象的所有写入组成的，由对象的初始化开始，在多数情况下，该顺序在每次运行之间都有所不同，但是在任意给定的程序执行里，系统中的所有线程必须一致同意此顺序，如果问题中的对象不是如5.2节所述的原子类型之一，你就得负责确认有足够的同步，来确保线程一致同意每个变量的修改顺序，如果不同的线程看到的是一个变量的不同的顺序值，就会有数据竞争和未定义行为，如果使用原子操作，编译器将负责确保必要的同步已就位

//这一要求意味着某些投机性的执行时禁止的，因为一旦线程已在修改顺序中看到了某个特定项，则后续读取操作必须返回更晚的值，同时来自该线程对此对象后续的写入操作在修改顺序中也必须发生得更晚，同样，在同一线程中，在对象的写操作之后的读取，就必须返回要么写入的值，要么在该对象的修改中更晚发生得另一值，尽管所有的线程都必须一致同意程序中每一个独立对象的修改顺序，但却不必一致同意不同兑现上操作的相对顺序，参见5.3.3节更多地了解线程间的操作顺序

//那么，是什么构成了原子操作，它又是如何用来强制顺序的

#pragma clang diagnostic pop
