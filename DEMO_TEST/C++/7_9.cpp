//
//  7_9.cpp
//  123
//
//  Created by chenyanan on 2017/5/12.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//7.3 编写无锁数据结构的准则

//如果你看了本章的所有列子，那么你就会了解使无锁代码正确的复杂性，如果你准备设计你自己的数据结构，那么需要注意一些准则，第6章开始部分提到的关于并发数据结构的总体准则依然是适用的，但是你需要更多准则，我将从这些例子中提取出一些有用的准则，当你设计你自己的无锁数据结构的时可以参考

//7.3.1 准则:使用std::memory_order_seq_cst作为原型

//std::memory_order_seq_cst比别的内存顺序更容易理解，因为所有操作形成了总的顺序，在这章的例子中，我们都是从std::memory_order_seq_cst开始，并且一旦基础操作正确的情况下才会放松内存顺序约束，从这个意义上来说，使用别的内存顺序是在优化，但是你要避免过早优化，通常只有当你看到所有代码对数据结构核心操作正确的时候，才能决定哪些操作可以放松，过早的考虑其他内存顺序只会带啦麻烦，代码可能会正确工作，单丝并不保证是这样的，仅仅跑程序是不够的，除非有个算法检查器来系统测试所有与具体顺序保证相符的可见线程组合

//7.3.2 准则:使用无锁的内存回收模式

//无锁代码最大的问题之一就是内存管理，当别的线程仍然引用对象的时候就不能删除它们，这是最基本的，但是你仍然想尽快删除它们来避免过多的内存消耗，本章将介绍三种方法来确保可以安全回收内存

//等待直到没有线程访问该数据结构，并且删除所有等待删除的对象
//使用风险指针来确定线程正在访问一个特定的对象
//引用计数对象，只有直到没有显著的引用时才删除它们

//在所有的情况下，关键的想法就是使用一些放方法来记录有多少线程在访问一个特定的对象，并且只删除不再被引用的对象，有很多方法可以回收无锁数据结构的内存，例如，使用垃圾回收器是很理想的方案，当你不再使用结点的时候，来及回收期可以释放节点，在这种情况下写程序就简单一些

//另一个方法就是回收结点，情切当数据结构被销毁的时候才完全释放它们，因为结点是重复使用的，内存永远不会失效，这样避免未定义行为的困难就不存在了，缺点就是另一个问题变得更常见，这就是所谓的ABA问题

//7.3.3 准则:当心ABA问题
//ABA问题是任何基于比较/交换的算法都必须提防的问题，它是这样的

//1 线程1读取一个原子变量x，并且发现它的值为A
//2 线程1基于这个值执行了一些操作，例如解引用它(如果它是指针的话)或者做一些查找操作
//3 线程1被操作系统阻塞了
//4 另一个线程在x上执行了一些操作，将它的值改为B
//5 第三个线程更改了与值A相关的值，因此线程1持有的数值就不再有效了，这个变化有可能很大，如释放它所指向的内存或者改变相关的值一样
//6 第三个线程基于新值将x的值改回A，如果这是一个指针，那么就可能是一个新的对象，此对象刚好与先前的对象使用了相同的地址
//7 线程1重新取得x，并在x上执行比较/交换操作，与A进行比较，比较/交换操作成功了(因为值确实是A)，但是这个A的值是错误的，第二步中读取的值不再有效，但是线程1并不知道，并且将破坏数据结构

//现在这里米有程序遇到这种问题，但是写无锁程序的时候就很容易遇到这种问题，最常用的避免这种问题的方法就是在变量x上使用一个ABA计数器，此时，x加上计数器这样一个结合的数据结构就将作为一个单位，比较/交换就会基于这个单位进行操作，每次修改值的时候，计数器的值都会加一，即使x的值是一样的，如果另一个线程修改了x，比较/交换操作将会失败

//使用空闲表或者回收结点而不是将它返回给分配器，使得ABA问题在算法中很常见

//7.3.4 准则:识别忙于等待的循环以及辅助其他线程

//在最后的队列例子中，可以看出执行如队列操作的线程必须等待另一个执行入队操作的线程必须等待另一个执行入队操作的线程完成操作后才能进行，更不用说，将会出现忙则等待循环，等待的线程不能继续执行的时候回浪费CPU时间，如果最终以忙则等待循环结束，那么你事实上就有了阻塞操作，并且也可能会使用互斥元和锁，通过修改程序，如果安排等待中的线程运行的话，那么此线程会在最初的线程完成操作前继续执行未完成的步骤，此时就可以消除忙则等待，并且操作不再被阻塞，在队列的例子中，这就需要将数据成员变为原子变量而不是非原子变量，并且使用比较/交换操作设置它，但是在更复杂的数据结构中需要改变更多

#pragma clang diagnostic pop
