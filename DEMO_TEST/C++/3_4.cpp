//
//  3_4.cpp
//  123
//
//  Created by chenyanan on 2017/4/21.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <stdio.h>

//选项1.传入引用
//第一个选项是把你希望接受出栈值的变量的引用，作为参数传递给对pop()的调用

/*

std::vector<int> result;
some_stack.pop(result)

*/
 
//这在很多情况下都适用，但它有个明显的缺点，要求调用代码在调用之前先构造一个该栈值类型的实例，以便将其作为目标传入，对于某些类型而言这是行不通的，因为构造一个实例在时间和资源方面是非常昂贵的，对于其他类型，这并不总是可能的，因为构造函数需要参数，而在代码的这个位置不一定可用，最后，它要求所存储的类型是可赋值的，这是一个重要的限制，许多用户定义的类型不支持赋值，尽管他们可能支持移动构造函数，或者甚至是拷贝构造函数



//选项2.要求不引发异常的拷贝构造函数或移动构造函数
//对于有返回值的pop()而言只有一个异常安全问题，就是以值进行的返回可能引发异常，许多类型具有不引发异常的拷贝构造函数，并且在C++标准中有了新的右值引用的支持，越来越多的类型将不会引发异常的移动构造函数，即便他们的拷贝构造函数会如此，一个有效的选择，就是把对线程安全堆栈的使用，限制在能够安全的通过值来返回且不引发异常的类型之内，虽然这样安全了，但并不理想，尽管你可以在编译时使用std::is_nothrow_copy_constructible和std::is_nothrow_move_constructible类型特征，来检测一个不引发异常的拷贝或移动构造函数的存在，但这却很受限制，相比于具有不能引发异常的拷贝或移动构造函数的类型，有更多的用户定义类型具有能够引发异常的拷贝构造函数且没有移动构造函数(尽管这会随着人们习惯了C++11中对右值引用的支持而改变)，如果这种类型不能被存储在你的线程安全堆栈中，是不幸的



//选项3.返回指向出栈项的指针
//第三个选择是返回一个指向出栈项的指针，而非通过值来返回该项，其优点是指针可以被自由地复制而不会引发异常，这样你就避免了Cargill的异常问题，其缺点是，返回一个指针时需要一种手段来管理分配给对象的内存，对于像整数这样简单的类型，这种内存管理的成本可能会超过仅通过值来返回该类型，对于任何使用此选项的接口，std::shared_ptr会是指针类型的一个好的选择，它不仅避免了内存泄漏，因为一旦最后一个指针被销毁则该对象也会被销毁，并且库可以完全控制内存分配方案且不必使用new和delete，对于优化用途来说这是很重要的，要求用new分别分配堆栈中的内一个对象，会比原来非线程安全的版本带来大得多的开销



//选项4.同时提供选项1以及2或3
//灵活性永远不应被排除在外，特别是通用的代码中，如果你选择选项2或3，那么同时提供选项1也是相对容易的，这也是你的代码的用户提供了选择的能力，为了很小的额外成本，哪个选项对他们是最合适的

#pragma clang diagnostic pop