//
//  7_2.cpp
//  123
//
//  Created by chenyanan on 2017/5/11.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//7.1.1 非阻塞数据结构的类型

//第5章中，我们实现了一种使用std::atomic_flag作为自旋锁的基本互斥元，清单7.1中复刻了该代码

//清单7.1 使用std::atomic_flag的自旋锁互斥元的实现

class spinlock_mutex
{
    std::atomic_flag flag;
public:
    spinlock_mutex() : flag(ATOMIC_FLAG_INIT) {}
    
    void lock()
    {
        while (flag.test_and_set(std::memory_order_acquire));
    }
    
    void unlock()
    {
        flag.clear(std::memory_order_release);
    }
};

//这段代码不调用任何阻塞函数，lock()一直循环直到对test_and_set()的调用返回false，这就是自旋锁(spinlock)名称的由来，代码围绕着循环"旋转"，无论如何，这里没有阻塞调用，因此任何使用此互斥元来保护共享数据的代码因而都是费阻塞的，然而，它并非无锁的，它仍然是一个互斥元，并且一次仍然只能被一个线程锁定，我们来看无锁的定义，这样就能明白哪些类型的数据结构是被涉及的

//7.1.2 无锁数据结构

//对于有资格称为无锁的数据结构，就必须能够让多余一个线程可以并发地访问此数据结构，这些线程不需要做相同的操作，无锁队列可以允许一个线程push的同时另一个线程pop，但是如果两个线程同时试图插push新数据项的时候，就会打破无锁队列，不仅如此，如果一个访问数据结构的线程在操作中途被调度器挂起的话，别的线程必须仍然能够完成操作而无需等待挂起的线程

//在数据结构上使用比较/交换操作的算法经常在其中包含循环，使用比较/交换操作是因为有可能另一个线程正在同时修改数据，这种情况下，代码就需要在试图重新比较/交换前重做部分操作，如果比较/交换操作最终在其他线程都被中断的情况下成功，那么这种代码仍然是无锁的，如果没有，最起码要使用自旋锁，是非阻塞的而不是无锁的

//具有这种循环的无锁算法可能会导致一个线程承受饥饿，如果另一个线程在"错误的"时间进行操作，那么当第一个线程持续重试其操作，别的线程则可以继续前进，能够避免此类问题的数据结构是无等待，也是无锁的

//7.1.3 无等待的数据结构

//无等待的数据结构是一种无锁的数据结构，并且有着额外的特性，每个访问数据结构的线程都可以在有限数量的步骤内完成它的操作，而不用管别的线程的行为，因为其他线程的冲突而可能卷入无限次重试的算法不是无等待的

//正确地编写无等待的数据结构是及其困难的，为了确保每个线程都能够在有限步骤内完成它的操作，就必须保证每个操作都可以在一个线程周期内执行，并且一个线程执行的操作不会导致另一个线程上操作的失败，这会使得各种操作的整体算法变得相当复杂

//鉴于正确地设计无锁或无等待数据结构是如此困难，你需要一些很好的理由来支持这一点，你需要确信收益胜于代价，所以，让我们来检验影响此平衡的重点

//7.1.4 无锁数据结构的优点与缺点

//到了这一步，使用无锁数据结构的最主要的原因就是为了实现最大程度的并发，对于基于锁的容器，总是有可能一个线程必须阻塞，并在可以继续前等待另一个线程完成其操作，互斥元锁的目的就是通过互斥来阻止并发，使用无锁数据结构时，某些线程一步步地执行操作，每个线程都可以继续执行而不需要等待，这是一种和希望得到但是却很难得到的特性，都很容易在编写基本的一个自旋锁时告终

//使用无锁数据结构的第二个原因是健壮性，当一个线程在持有锁的时候终止，那个数据结构就永远被破坏了，但是如果一个线程在操作无锁数据结构时终止了，就不会丢失任何数据，除了此线程的数据之外，其他线程可以继续正常执行

//另一方面，如果不能排除线程访问数据结构，那么就必须确保持有不变量或选择可以持有的替代的不变量，并且，必须注意你加于操作上的顺序限制，为了避免与数据竞争有关的未定义行为，你就必须在修改时使用原子操作，仅仅如此还是不够的，你必须确保这个改变以正确的顺序对其他线程是可见的，所有这些都意味着设计线程安全数据结构时，不使用锁比使用锁要困难的多

//因为不使用任何锁，因此无锁数据结构是不会发生死锁的，尽管有可能存在活锁，当两个线程都试图修改数据结构，但是对于每个线程来说，另一个线程所做的修改都会要求此线程的操作被重新执行，因此这两个线程都会一直循环和不断尝试，在这种情况下就会发生活锁，除非某个线程先到达(通过协议，通过更快，或完全靠运气)，不然此循环会一直继续下去，在这个简单的例子中，活锁通常是短暂的，因为它们取决于线程的精确调度，因此，活锁会降低性能而不会导致长期的问题，但是也是需要注意的事情，根据定义，无等待的代码无法忍受活锁，因为它执行操作的步骤数通常是有上限的，另一方面，这种算法比别的算法更复杂，并且即使当没有线程存取数据结构的时候也需要执行更多的步骤

//这就带来了无锁和无等待代码的另一个缺点，尽管它可以增加在数据结构上操作的并发能力，并且减少了线程等待的时间，但是它可能降低整体的性能，首先，无锁代码使用的原子操作可能比非原子操作要慢很多，并且与基于锁数据结构的互斥元锁代码相比，无锁数据结构中需要跟多的原子操作，不仅如此，硬件必须在存取同样的原子变量的线程同步数据，正如你将在第8章中看到的，与多个线程存取同样的原子变量相关的乒乓缓存可能会成为一种显著的性能消耗，总而言之，在选择任何一种方式前，检查基于锁的数据结构和无锁数据结构的相关性能方面(是否为最坏等待时间，平均等待时间，总的执行时间，或其他方面)是很重要的

//下面我们来看一些例子

//7.2 无锁数据结构的例子

//为了展示在设计无锁数据结构时使用的一些技术，我么你来看一些简单数据结构的无锁实现，我们不仅举例子描述了一些列有用的数据结构的实现，而且将举例子强调无锁数据结构设计中比较特殊的部分

//就像之前提到的，依赖于使用原子操作的无锁数据结构，以及与之相关联的内存顺序保证是为了确保数据以正确的顺序对其他线程可见，起初，我们为所有原子操作都使用默认的memory_order_seq_cst内存顺序，因为这是最简单的(记住所有的memory_order_seq_cst操作构成了全局顺序)，但是在后来的例子中，我们考虑降低一些排序约束到memory_order_acquire，memory_order_release，甚至memory_order_relaxed中，尽管在这些例子中都未直接使用互斥元锁，但是需要记住的是，只有std::atomic_flag保证在实现中是不使用锁的，在一些平台上，有些看上去无锁的代码，实际上却可能使用了C++标准库实现的内部锁(参见第5章)，在这些平台上，一个简单的基于锁的数据结构可能更适合，但是还有比这更重要的是，在选择一种实现的时候，必须先确定你的要求，然后考虑有哪些选择可以满足此要求

//因此，我们追溯到一种最简单的数据结构:栈



#pragma clang diagnostic pop
