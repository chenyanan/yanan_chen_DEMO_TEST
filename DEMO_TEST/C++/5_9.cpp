//
//  5_9.cpp
//  123
//
//  Created by chenyanan on 2017/5/5.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//4. 理解松散顺序

//为了理解这是如何工作的，想象每个变量是一个在小间隔里使用记事本的人，在他的记事本上有一列值，你可以打电话给他，要求他给你一个值，或者你可以告诉他写下了一个新值，如果你告诉他写下新值，他就将其写在列表底部，如果你向他要一个值，他就为你从类表中读取一个数字

//第一次你跟这个人交谈，如果你向他要一个值，此时他可能从他记事本上的列表里任意给你一个值，如果你接着向他要另一个值，他可能会再次给你同一个值，或是从列表下放给你一个，他永远不会给你一个在列表中更上面的值，如果你告诉他写下一个数字，然后再要一个值，他要么给你刚才你让他写下的数字，或者是列表上在那以下的数字

//假设某一次他的列表以这些值开始5、10、23、3、1、2，如果你要一个值，你会得到其中的任意一个，如果他给你10，下一次他可能再给你一个10，或者后面的其他值，但不会是5，如果你呼叫他5此次，举个例子，他可能会说"10,10,1,2,2"，如果你告诉他写下42，他会将其添加子啊列表末尾，如果你再向他要数字，他将一直告诉你"42"，直到他的列表上有另一个数，并且他愿意告诉你时

//现在，假设你的朋友Carl也有这个人的号码，Carl也可以打电话给他，要么请他写下一个数字或是索取一个数字，他跟对待你一样，对Carl应用相同的规则，他只有一部电话，因此它一次只能处理你们中的一个人，所以他记事本上的列表是一个非常直观的列表，但是，仅仅因为你让他写下了新的号码，并不意味着他必须将其告诉Carl,反之亦然，如果Carl向他索取一个数字，并被告知"23"，然后仅仅因为你要求这个人写下42并不意味着他下一次就会告诉Carl，他可能会见23、3、1、2、42这些数字中的任何一个告诉Carl，或者甚至是你在呼叫他之后，Fred告诉他写下来的67，他很可能会告诉Carl"23、3、3、1、67"，这与他告诉你的也没什么矛盾，就像是他为每个人设了一个小小的移动便签，把他对谁说了什么数够进行了记录，如图5.5所示

//           5
//           10
//           23   carl dave
//           3
//           1
//      anne 2
//           42   you
//      fred 67

//现在假设不仅仅是一个人在一个小隔间，而是整个隔间群，有一大帮带着电话和笔记本的人，这些都是我们的原子变量，每一个变量都有自己的修改顺序(笔记本上的列表的值)，但是它们之间完全没有关系，如果人一样一个呼叫者(你，Carl，Anne，Dave，Fred)是一个线程，那么这就是每个操作都使用memory_order-relaxed是你所得到的东西，还有一些你可以告诉隔间里的人的额外的事情，比如"记下这个号码，并告诉我列表的底部是什么"(exchange)和"写下这个数字，如果列表底部的数字正是它，否则告诉我应该猜到什么"(compare_exchange_strong)，但是这并不影响一般的原则

//如果你仔细的想一想清单5.5中的程序逻辑，write_x_then_y就像是某个家伙打电话告诉小隔间x中的人让他写下true，然后再打电话给小隔间y中的人让他写下true，运行read_y_then_x的线程不断地呼叫小隔间y中的人询问一个值，一直到他说true，然后再向小隔间x中的人询问值，这个在小隔间x中的人没有义务熬诉你他列表上的任何一个具体的值，并且还有权利说false

//这就使得松散个原子操作难以处理，他们必须与具有更强的顺序语义的原子操作结合其他使用，以便在线程间同步中发挥作用，我强烈建议避免松散的原子操作，除非绝对必要，即便这样，也应该及其谨慎地使用之，在清单5.5中，仅仅是两个线程和两个变量就能让所得到的记过这样不直观，鉴于此，不难想象在涉及更多线程和变量的时候，会变得多么复杂

//一种避免全面顺序一致性开销的达到额外同步的方法，是使用获取-释放顺序

#pragma clang diagnostic pop
