//
//  6_1.cpp
//  123
//
//  Created by chenyanan on 2017/5/5.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//6.2 基于锁的并发数据结构

//设计基于锁的并发数据结构关键是要确保存取数据时要锁住正确的互斥元，并且要确保将锁的时间最小化，只用一个互斥元保护一个数据结构是很困难的，你需要确保此数据在互斥锁保护区域之外不会被存取，并且不会再发生接口所固有的竞争现象，如果使用独立的互斥元来保护数据结构的独立部分，问题会变得更复杂，并且如果数据结构上的操作需要多个互斥元被锁住就有可能产生死锁，因此，设计有多个互斥元你的数据结构时，需要比设计只有一个互斥元的数据结构考虑得更细致

//在这部分，将6.1.1节中的标准运用到一些简单数据结构的设计中，是用互斥元和锁来保护数据，在不同的情况下，你可以找到机会在确保数据结构仍然线程安全的情况下能够有更大的并发性

//首先我们回顾一下第3章中提到的栈实现，这大约是最简单的一种数据结构，而且它只是使用了一个互斥元，它是否真的线程安全?它距离实现真正的并发性到底有多远呢？

//6.2.1 使用锁的线程安全栈

//在清单6.1中会重现第3章中的线程安全栈，目的是为std::stack<>写一个相似的线程安全数据结构，支持数据入栈和出栈

//清单6.1 线程安全栈的类定义

#include <exception>
#include <stack>

struct empty_stack : std::exception
{
    const char* what() const throw();
};

template<typename T>
class threadsafe_stack
{
private:
    std::stack<T> data;
    mutable std::mutex m;
public:
    threadsafe_stack() {}
    threadsafe_stack(const threadsafe_stack& other)
    {
        std::lock_guard<std::mutex> lock(other.m);
        data = other.data;
    }
    threadsafe_stack& operator=(const threadsafe_stack&) = delete;
    
    void push(T new_value)
    {
        std::lock_guard<std::mutex> lock(m);
        data.push(std::move(new_value));   //①
    }
    
    std::shared_ptr<T> pop()
    {
        std::lock_guard<std::mutex> lock(m);
        if (data.empty())
            throw empty_stack();   //②
        const std::shared_ptr<T> res(std::make_shared<T>(std::move(data.top())));   //③
        data.pop();   //④
        return res;
    }
    
    void pop(T& value)
    {
        std::lock_guard<std::mutex> lock(m);
        if (data.empty())
            throw empty_stack();
        value = std::move(data.top());   //⑤
        data.pop();   //⑥
    }
    
    bool empty() const
    {
        std::lock_guard<std::mutex> lock(m);
        return data.empty();
    }
};

//让我们轮流看看每个准则，以及他们是如何应用的

//首先，如你所见，基本的线程安全是通过使用互斥锁m保护成员函数来实现的，这就确保了同一时间只有一个线程在存取数据，因此每个成员函数都保持了不变量，没有线程会看到一个破坏的不变量

//其次，empty()和任何一个pop()函数间都可能产生竞争条件，但是当pop()持有锁的时候，这段代码会明确地检查它所包含的栈，因此竞争条件就不成问题了，调用pop()时会直接返回出栈的数据项，就避免了类似于std::stack<>中单独的成员函数top()和pop()间可能产生的竞争条件

//下一个，这里可能会抛出一些异常，锁住一个互斥元你可能会抛出异常，这不仅是极其罕见的(因为这就表明互斥元有问题或者缺乏系统资源)，也是每个成员函数的第一个操作，因为没有数据被修改，所以是安全的，解锁一个互斥元总是成功的，所以总是安全的，并且使用std::lock_guard<>保证了在成员函数结束的时候互斥元不会被锁定

//调用data.push()①可能会抛出异常，如果复制或者移动数据项抛出异常或者不能分配足够的内存来扩展下层的数据结构，不管怎样，std::stack<>保证了它是安全的，因此这也不是一个问题

//在函数pop()重载的第一重形式中，它的代码可能会抛出一个empty_stack异常②，但是没有做出任何修改，因此它是安全的，创建res时因为一些原因可能会抛出异常，调用std::make_shared可能会抛出异常，因为它无法为新对象和需要引用计数的内部数据分配内存，当复制构造函数或移动构造函数中返回的数据项被复制/移动到新分配的内存时也可能会抛出异常，在这两种情况下，C++运行库和标准库确保没有内存泄露并且写对象(如果存在的话)被正确销毁，因为你仍然没有修改下层的栈，所以没有问题，作为结果的返回值，调用data.pop()④保证了不会抛出异常，因此pop()的重载是异常安全的

//函数pop()重载的第二种形式是类似的，只不过这次是拷贝复制或移动赋值操作符抛出异常⑤，而不是构造新对象和一个std::shared_ptr实例抛出异常，同样，你实际上并没有修改数据结构直到调用data.pop()⑥，这仍然保证了不会抛出异常，因此这一重载也是异常安全的

//最后，empty()不修改任何数据，因此是异常安全的

//这里会有产生死锁的可能，因为当持有锁时调用了用户代码:拷贝构造函数或移动构造函数①、③，以及内涵数据项的拷贝赋值操作或移动赋值操作⑤，以及可能有用户定义的new操作符，如果当数据项被插入栈或从栈中移出时，这些函数调用了栈的成员函数，或者当栈成员函数被调用时，这些函数请求一个锁的时候保持着另一个锁，就有可能产生死锁，然而，要求栈的使用者做出如下保证是明智的:你不能理所当然地在没有复制数据项或为之分配内存的情况下，将它加入栈或者从栈中移走它

//因为所有的成员函数都使用std::lock_guard<>来保护数据，所以多个线程调用stack的成员你函数是安全的，成员函数中只有构造函数和析构函数是不安全的，但是这不是一个特殊问题，对象只能被构造和销毁一次，在一个没有完全构造好的对象或部分西沟对象上调用成员函数永远不是一个好主意，因此，使用者必须保证在它被完全构造前别的线程不能存取栈，并且在它被完全销毁前，所有线程结束存取栈

//尽管对多线程来说，因为使用了锁，每次只有一个线程对栈数据结构进行操作，所以同时调用成员函数是安全的，但是当stack上存在显著的竞争时，县城序列化可能会限制应用的性能，当一个线程在等待锁的时候，它就做不了任何有用的工作，并且，栈没有为邓艾数据项被插入的线程提供任何有用的工作，并且，栈没有为等待数据项被插入的线程提供任何方式的准备，因此如果一个线程需要等待，它就会反复地调用empty()，或者只是调用pop()，并且捕捉empty_stack异常，如果这种情况发生的话，这种栈实现就成为一个比较糟糕的选择，因为一个等待中的线程要么消耗宝贵的资源在检查数据上，要么用户必须写外部的等待和通知代码(比如，使用条件变量),而这就有可能让内部锁变得无效并且造成浪费，第4章中的队列在数据结构中使用了条件变量，这就提供了一种数据结构中包含等待的方法，因此下面我们来看一看

#pragma clang diagnostic pop
