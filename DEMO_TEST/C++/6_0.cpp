//
//  6_0.cpp
//  123
//
//  Created by chenyanan on 2017/5/5.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//第5章 设计基于锁的并发数据结构

//本章主要内容

//为并发设计数据结构的含义
//这么做的准则
//实现设计满足并发性的数据结构的例子

//上一章中我们寻找原子操作和存储器模式的底层细节，在这一章中，我们先不探讨底层细节(尽管第7章中我们需要用到它们)而是考虑数据结构

//程序设计问题中选择什么样的数据结构是总体解决方法的关键部分，对于并行程序设计问题也不例外，如果多线程用到了数据结构，那么此数据结构要么完全不可变，即从不繁盛变化也不需要同步，要么程序设计中就要保障线程间能正确同步变化，一种选择就是使用单独的互斥元和外部锁来保护数据，使用我们在第3章和第4章中提到的技术，另外一种选择就是设计一个可以同时访问的数据结构

//当为并发设计数据结构时，你可以使用前面章节中介绍的多线程应用程序中的基本构造模块，例如互斥元和条件变量，实际上，我们已经看到了几个例子，显示了如何将这些基本部分组合起来写入数据结构并保证当前多线程数据的安全性

//这章中，我们首先考虑为并发性设计数据结构时的一般准则，然后我们采取基本构造模块和条件变量，并且在我们进入到更加复杂的数据结构前先回顾一下这些基础数据结构，在第7章中，我们考虑如何糊掉基础并且使用第5张中描述的原子操作来建立无锁的数据结构

//那么，言归正传，让我们考虑为并发性设计一种数据结构时需要涉及到哪些方面

//6.1 为并发设计的含义是什么

//在最基本的层面，为并发设计数据结构意味着多个线程可以同时使用此数据结构，执行相同或不同的操作，并且每个线程都有数据结构的一致性视图，不会丢失或破坏数据数据，维持所有不变亮，并且没有不确定的竞争条件，此种数据结构就被称为线程安全的，通常，只有在特定的并发存取下，一种数据结构才是安全的，很有可能出现这种情况，就是多个线程对数据结构执行同一种操作，然而另一个线程的操作需要进行独占访问，或者，也需多个线程执行不同的操作，它们并发地存取某个数据结构是安全的，然而多个线程执行相同的操作，它们并发地存取某个数据结构可能会有问题

//实际上并发射极远远不只是为多个线程提供存取数据结构的并发机会，本质上，互斥元提供的是互斥，一次只允许一个线程获取互斥元的锁，一个互斥元通过明确阻止对它所保护的数据进行并发存取来保护数据结构

//这被称为序列化，多个线程轮流存取互斥元保护的数据，它们必须线性地而非并发地存取数据，所以，你必须仔细考虑数据结构的设计来实现真正的并发存取，一些数据结构比别的数据结构在并发性上有更大的范围，但是在所有的情况下，其思想是一致的，更小的保护区域，更少的操作被序列化，以及更高的并发潜能

//在我们考虑某个数据结构设计前，我们先来回顾设计并发性时需要考虑的一些简单准则

//为并发设计数据结构的准则

//就像我提到的，为并发存取设计数据结构时，你需要考虑两方面，保证存取是安全的以及允许真正的并发存取，第3章中我阐述了如何使得数据结构线程安全的基本原理

//保证当数据结构不变性被别的线程破坏时的状态不被任何别的线程看到

//注意避免数据结构接口所固有的竞争现象，通过为完整操作提供函数，而不是提供操作步骤

//注意当出现例外时，数据结构是怎样来保证不变性不被破坏的

//当使用数据结构时，通过限制锁的范围和避免使用嵌套锁，来见底产生死锁的机会

//在考虑这些细节之前，先考虑使用数据结构时的限制条件也是很重要的，如果一个函数通过特殊函数使用数据结构，那么其他县城调用哪个函数是安全的？

//这是要考虑的关键性问题，大多数构造函数和析构函数需要以独占方式访问数据结构，但是需要使用者保证他们在构造函数完成前或者析构函数开始后没有被使用，如果数据结构支持复制、swap()、或复制构造，那么作为数据结构的设计者，就需要决定这些操作与别的操作同时被调用时是否安全，或者是否需要使用者保证互斥访问，即使操作数据结构的大部分函数可能被多线程同时访问时也没有问题

//第二个要考虑的方面就是实现真正的并发存取，我没办法在这里给出详尽的准则，而是，这里有一列问题，作为数据结构设计者需要问问自己

//锁的范文能否被限定，使得一个操作的一部分可以在锁外被执行？

//数据结构的不同部分能否被不同的互斥元保护

//是否所有操作需要同样级别的保护

//数据结构的一个小改变能否在不影响操作语义情况下提高并发性的机会

//所有这些问题都被一个想法所指导，如何能够最小化必然发生的序列化，并且能够最大限度地实现并发性？通常，但多个线程仅仅读取数据结构时可以并发访问此数据结构，但是一个线程必须以独占方式修改数据结构，使用构造函数boost::shared_mutex可以实现此功能，而且，很快你就会看到，数据结构支持执行不同操作的线程和执行相同操作的序列化线程并发访问它

//最简单的线程安全数据结构通常使用互斥元和锁来保护数据，就像第3章中提到的，比较简单的方式是保证背刺只有一个线程使用此数据结构，尽管这种方式也会存在问题，为了让你轻松了解线程安全数据结构的设计，本章我们研究这种基于锁的数据结构，在第7章中我们将研究无锁的并发数据结构的设计

#pragma clang diagnostic pop
