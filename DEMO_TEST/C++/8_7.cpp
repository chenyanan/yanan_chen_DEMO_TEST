//
//  8_7.cpp
//  DEMO_TEST
//
//  Created by chenyanan on 2017/6/12.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <numeric>
#include <thread>
#include <mutex>
#include <future>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//8.4.2 可扩展性和阿姆达尔定律

//可扩展性是关于确保你的应用可以利用系统中增加的处理器，一种极端情况就是你有一个完全不能扩展的单线程应用，即使你再系统中增加100个处理器也不会改变性能，另一种极端情况是你有类似SETI@Home的项目，被设计用来处理成千上万的附加的处理器(以用户将个人计算机增加到网络中的形式)

//对于任何给定的多线程程序，当程序运行时，执行有用工作的线程的数量会发生变化，即使每个线程都在做有用的操作，初始化引用的时候可能只有一个线程，然后就有一个任务生成其他的线程，但是即使那样也是一个不太可能发生的方案，线程经常花时间等待彼此或者I/O操作完成

//除非每次线程等待事情(无论是什么事情)的时候都有另一个线程在处理器上替代它，否则就有一个可以进行有用工作的处理器处于闲置状态

//一种简单的方法就是将程序划分为只有一个线程在做有用的工作"串行的"部分和所有可以获得的处理器都在做有用工作的"并行的"部分，如果你在有更多处理器的系统上运行你的应用，理论上就可以更快地完成"并行"部分，因为可以在更多的处理器间划分工作，但是"串行的"部分仍然是串行的，在这样一种简单假设下，你可以通过增加处理器数量来估计可以获得的性能，如果"连续的"部分组成程序的一个部分fs，那么使用N个处理器获得的性能P就可以估计为P = 1 / (fs + (1 - fs) / N),这就是阿姆达尔定律，当谈论并发代码性能的时候经常被引用，如果所有事情都能被并行，那么串行部分就为0，加速就是N，或者，如果串行部分是三分之一，即使有无限多的处理器，你也不会得到超过3的加速

//尽管如此，这是一种很理想的情况，因为任务很少可以像方程式所需要的那样被无穷划分，并且所有事情都达到它所假设的CPU界限是很少出现的，正如你看到的，线程执行的时候回等待很多事情

//阿姆达尔定律中有一点是很明确的，那就是当你为性能使用并发的时候，值得考虑总体应用的设计来最大化并发的可能性，并且确保处理器始终有有用的工作来完成，如果你可以减少"串行"部分或者减少线程等待的可能性，你就可以提高在有更多处理器的系统上的性能，或者，如果你可以为系统提供更多的数据，并且保持并行部分准备工作，就可以减少串行部分，增加性能P的值

//从根本上说，可扩展性就是当增加更多的处理器的时候，可以减少它执行操作的事件或者增加在一段时间内处理的数据数量，有时这两点是相同的(如果每个元素可以处理得更快，那么你就可以处理更多数据)，但是并不总是一样的，在选择在线程间划分工作的方法之前，识别出可扩展性的那些方面对你很重要是很必要的

//在这部分的开始我就提到过线程并不总有有用的工作来做，有时它们必须等待别的线程，或者等待I/O操作完成，或者别的事情，如果在等待中你给系统一些有用的事情，你就可以有效的"隐藏"等待

//8.4.3 用多线程隐藏延迟
//在很多关于多线程代码性能的讨论中，我们都假设当它们真正的在处理器上运行时，线程在"全力以赴"的运行并且总是有有用的工作来做，这当然不是正确的，在应用代码中，线程在等待的时候总是平凡地被阻塞，例如，它们可能在等待一些I/O操作的完成，等待获得互斥元，等待另一个线程完成一些操作并且通知一个条件变量，或者只是休眠一段时间

//无论等待的原因是什么，如果你只有和系统中物理单元一样多的线程，那么有阻塞的线程就意味着你在浪费CPU时间，运行一个被阻塞的线程的处理器不做任何事情，因此，如果你知道一个线程将会有相当一部分时间在等待，那么你就可以通过运行一个或多个附加线程来使用那个空闲的CPU时间

//考虑一个病毒扫描应用，它使用管道线线程间划分工作，第一个线程搜索文件系统来检查文件并且将它们放到队列中，同时，另一个线程获得队列中的文件名，载入文件，并且扫描它们的病毒，你知道搜索文件系统的文件来扫描的线程肯定会打到I/O界限，因此你就可以通过运行一个附加的稻苗线程来使用"空闲的"CPU时间，那么你就有一个搜索文件线程，以及与系统中的物理核或者处理器相同数量的扫描线程，因为扫描线程可能也不得不从磁盘读取文件的重要部分来扫描它们，拥有更多扫描线程也是很有意义的，但是在某个时刻会有太多线程，系统会再次慢下来因为它花了更多时间切换程序，正如8.2.5节所描述

//任然，这是一个最优化问题，因此测量线程数量改变前后的性能时很重要的，最有的线程数量将很大程度上取决于工作的性质和线程等待的时间所占的比例

//取决于引用，它也可能用完空闲的CPU时间而没有运行附加的线程，那么使用可获得的异步I/O操作就很有意义了，那么当在背后执行I/O的时候，线程就可以执行别的有用的工作了，在别的情况下，如果一个线程在等待另一个线程执行一个操作，那么等待的线程就可以自己执行那个操作而不是被阻塞，正如第7章中的无锁队列，在一个极端的情况下，如果线程等待完成一个任务并且该任务没有被其他线程执行，等待的线程可以在它内部或者另一个未完成的任务中执行这个任务，清单8.1中你看到了这个例子，在排序程序中只要它需要的块没有排好序就不停地排序它

//有时它增加线程来确保外部事件及时被处理来增加系统响应性，而不是增加线程来确保所有可得到的处理器都被应用了

//8.4.4 用并发提高响应性
//很多现代图形用户接口框架是事件驱动的，使用者通过键盘输入或者移动鼠标在用户接口上执行操作，这会产生一系列的事件或者消息，稍后引用就会处理它，系统自己也会产生消息或者事件，为了确保所有时间和消息都能被正确处理，通常引用都有小面所示的一个时间循环

while (true)
{
    event_data event = get_event();
    if (event.type == quit)
        break;
    process(event);
}

//显然，API的细节是不同的，但是结构通常是一样的，等待一个事件，做需要的操作来处理它，然后等待下一个事件，如果你有单线程应用，就会导致长时间运行的任务很难被写入，如8.1.3节描述的，为了确保用户输入能被及时处理，get_event()和process()必须以合理的频率被调用，无论应用在做什么操作，这就意味着要么任务必须顶起暂停并且将控制交给事件循环，要么方便的嘶吼在代码中调用get_event()/process()代码，每一种选择都将任务的实现变得复杂了

//通过用并发分离关注点，你就可以将场任务在一个新线程上执行，并且用一个专用的GUI线程来处理事件，线程可以通过简单的方法互相访问，而不是必须以某种方式将事件处理代码放到任务代码中，清单8.6列出了这种分离的简单概括

//清单8.6 从任务线程中分离GUI线程

std::thread task_thread;
std::atomic<bool> task_cancelled(false);

void gui_thread()
{
    while (true)
    {
        event_data event = get_event();
        if (event.type == quit)
            break;
        process(event);
    }
}

void task()
{
    while (!task_complete() && !task_cancelled)
    {
        do_next_operation();
    }
    if (task_cancelled)
    {
        perform_cleanup();
    }
    else
    {
        post_gui_event(task_complete);
    }
}

void process(event_data const & event)
{
    switch(event.type)
    {
        case start_task:
            task_cancelled = false;
            task_thread = std::thread(task);
            break;
        case stop_task;
            task_cancelled = true;
            task_thread.join();
            break;
        case task_complete:
            task_thread.join();
            display_results();
            break;
        default:
            //...
    }
}

//通过这种凡事分离障碍，用户线程能够及时地影响事件，即使任务要执行很长时间，这种影响性通常是使用应用时用户体验的关键，无论何时执行一个特定操作(无论该操作是什么)，应用都会被完全锁住，这样使用起来就不方便了，通过提供一个专用的事件处理线程，GUI可以处理GUI特有的消息(例如调整窗口大小或者重画窗口)而不会中断耗时处理的执行，并且当它们确实影响长任务时会传递相关的消息

//本章你看到了设计并发代码的时候需要考虑的问题，就整体而言，这些问题是很大的，但是当你习惯了"多线程编程"，它们就会变得得心应手了，如果这些考虑对你来说很新，那么希望当你看到它们是如何影响多线程代码的具体例子的时候，可以变得更清晰



#pragma clang diagnostic pop
