//
//  4_0.cpp
//  123
//
//  Created by chenyanan on 2017/4/26.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//第4章 同步并发操作

//本章主要内容
//等待时间
//使用future来等待一次性事件
//有时间限制的等待
//使用操作的同步来简化代码

//在上一章中，我们看到了各种方法去保护在线程间共享的数据，但是有时候你不只是需要保护数据，还需要在独立的线程上进行同步操作，例如，一个线程在能够完成其任务之前可能需要等待另一个线程完成任务，一般来说，希望一个线程等待特定事件的发生或是一个条件变为true是常见的事情，索然通过定期检查"任务完成"的标识或是在共享数据中存储类似的东西也能做到这一点，但却不甚理想，对于像这样的线程间同步操作的需求是如此常见，以至于C++标准库提供了以条件变量和期望为形式的工具来处理它

//在本章中，我将讨论如何使用条件变量和期望来等待事件，以及如何使用它们来简化操作的同步


//4.1 等待事件或其他条件
//假设你征程坐在通宵列车运行，一个可以确保你在正确的车站下车的放阿飞就是整夜保持清醒并注意火车停靠的地方，你不会误站，但你到哪儿时就会觉得很累，或者，你可以查一下时间表，了解火车会在何时到达，将闹钟定的稍微提前一点，然后去睡觉，这是可以的，你不会错过站，但是如果火车晚点了，你就会醒得太早，也有可能闹钟的电池没电了，你就会睡过头以至于错过站，理想的状况是，你只管去睡觉，让某个人或某个东西在火车到站时叫醒你，无论何时

//这如何与线程相关呢？那么，如果一个线程正等待着第二个线程完成一项任务，它有几个选择，首先，它可以一直检查共享数据(由互斥元保护)中的标识，并且让第二个线程在完成任务时设置该标识，这有两项浪费，线程占用了宝贵的处理时间去反复检查该标识，以及当互斥元被等待的线程锁定后，就不能被任何其他线程锁定，两者都反对线程进行等待，因为它们限制了等待中的线程的可用资源，甚至阻止它在完成任务时设置标识，这类似于整夜保持清醒地与火车司机交谈，他不得不把火车开得更慢，因为你一直在干扰他，所以需要更长的时间才能到达，同样的，等待中的线程消耗了本可以被系统中其他线程使用的资源，并且最终等待的时间可能会比所需的更长

//第二个选择是使用std::this_thread::sleep_for()函数(参见4.3节)，让等待中的线程在检查之间休眠一会儿

bool flag;
std::mutex m;

void wait_for_flag()
{
    std::unique_lock<std::mutex> lk(m);
    while (!flag)
    {
        lk.unlock();   //①解锁互斥元
        std::this_thread::sleep_for(std::chrono::milliseconds(100));   //②休眠100毫秒
        lk.lock();   //③重新锁定互斥元
    }
}

//在这个循环里，函数在休眠之前②解锁该互斥元①，并在之后再次锁定之③，所以另一个线程有机会获取它并设置标识

//这是一个进步，因为线程在休眠时并不良妃处理时间，但得到正确的休眠时间是很难的，检查之间休眠得过短，线程仍然会浪费处理时间进行检查，休眠得过长，即使线程正在等待的任务已经完成，它还会继续休眠，导致延迟，这种过度休眠很少直接影响程序的操作，但它可能意味着在快节奏的游戏中丢帧，或者在实时应用程序中过度运行一个时间片

//第三个选择，同时也是首选选择，是使用C++标准库提供工具来等待事件本身，等待有另一个线程触发一个事件的最基本机制(例如前面提到的管道中存在的额外操作)是条件变量，从概念上说，条件变量与某些事件或其他条件相关，并且一个或多个线程可以等待该条件被满足，当某个线程已经确定条件得到满足，它就可以通知一个或多个正在条件变量上进行等待的线程，以便唤醒他们并让他们继续处理

#pragma clang diagnostic pop
