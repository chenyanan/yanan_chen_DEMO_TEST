//
//  3_13.cpp
//  123
//
//  Created by chenyanan on 2017/4/26.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#include <iostream>
#include <thread>
#include <mutex>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

//3.3.3 递归锁
//在使用std::mutex的情况下，一个线程试图锁定其已经拥有的互斥元是错误的，并且试图这么做将导致未定义行为，然而，在某些情况下，线程多次重新获取同一个互斥元却无需实现释放它是可取的，为了这个目的，C++标准库提供了std::recursive_mutex，它就像std::mutex一样，区别在于你可以在同一个线程中的单个实例上获取多个锁，在互斥元能够被另一个线程锁定之前，你必须释放所有的锁，因此如果你调用lock()三次，你必须也调用unlock()三次，正确使用std::lock_guard<std::recursive_mutex>和std::unique_lock<std::recursive_mutex>将会为你处理

//大多数时间，如果你觉得需要一个递归互斥元，你可能翻而需要改变你的设计，递归互斥元常用在一个类被设计成多线程并发访问的情况中，因此它具有一个互斥元来保护成员数据，每个公共成员函数锁定互斥元，进行工作，然后解锁互斥元，然而，有时一个公共成员函数调用另一个函数作为其操作的一部分是可取的，在这种情况下，第二个成员函数也将尝试锁定该互斥元，从而导致未定义行为，粗制滥造的解决方案，就是讲互斥元改为递归互斥元，这将允许在第二个成员函数中对互斥元的锁定成功进行，并且函数继续

//然而，这样的用法是不推荐的，因为它可能导致草率的想法和糟糕的设计，特别地，类的不变量在锁被持有时通常是损坏的，这意味着第二个成员函数需要工作，即便在被调用时使用的是损坏的不变量，通常最好是提取一个新的私有成员函数，该函数是从这两个成员函数中调用的，它不锁定互斥元(它认为互斥元已经被锁定)，然后，你可以仔细想想在什么情况下可以调用这个新函数以及在那些情况下数据的状态

//在本章中，我讨论了在线程之间共享数据时，有问题的竞争条件如何成为灾难，以及怎样使用std::mutex和精心设计接口以避免它们，你看到了互斥元不是万能药，也有它们自己的以死锁出现的问题，尽管C++标准库以std::lock()的形式提供了工具来帮助避免死锁，然后你看到了一些进一步的技术来避免死锁，接着简要看了一下锁的所有权转让，以围绕着为锁选择恰当的粒度的问题，最后，我介绍了为特定场景提供的替代的数据保护工具，例如std::call_once()和boost::shared_mutex

//然而，还有一件事我没有提到，就是等待来自其他线程的输入，我们的线程安全栈在栈为空的情况下只是引发异常，因此如果一个线程需要等待另一个线程来讲一个值压入栈中(毕竟,这是线程安全栈的主要用途之一)，它将不得不反复尝试弹出值，如果引发异常则重试，这回消耗宝贵的处理时间进行检查，而没有实际取得任何进展，的确，不断地检查可能会通过阻止系统中其他线程的运行而阻碍进度，我们需要的是以某种方法让一个线程等待另一个线程完成任务，而无需耗费CPU时间，第四章构建在已经讨论过的用于保护共享数据的工具上，介绍了C++中用于线程间同步操作的各种机制，第六章展示了如何使用它们来构建更大的可复用的数据结构

//3.4 小节

//在本章中，我讨论了在线程之间共享数据时，有问题的竞争条件如何成为灾难，以及怎样使用std::mutex和精心设计接口以避免它们，你看到了互斥元不是万能药，也有它们自己的以死锁形式出现的问题，尽管C++标准库以std::lock()的形式提供了工具来帮助避免死锁，然后，你看到了一些进一步的技术来避免死锁，接着简要看了一下所的所有权的转让，以围绕着为锁选择恰当的粒度的问题，最后，我介绍了为特定场景提供的替代的数据保护工具，例如std::call_once()和boost::shared_mutex

//然而，还有一件事我没有提到，就是等待来自其他线程的输入，我们的线程安全栈在栈为空的情况下只是引发异常，因此如果一个线程需要等待另一个线程来将一个值压入栈中(毕竟，这是线程安全栈的主要用途之一)，它将不得不反复尝试弹出值，如果引发异常则重试，这回消耗宝贵的处理时间来进行检查，而没有实际取得任何进展，的确，不断地检查可能会通过阻止系统中其他现场的运行而阻碍进度，我么你需要的是以某种方法让一个线程等待另一个线程完成任务，而无需耗费CPU时间，第4章构建在已经讨论过的用于保护共享数据的工具上，介绍了C++中用于线程间同步操作的各种机制，第6章展示了如何使用它们来构建更大的可复用的数据结构

#pragma clang diagnostic pop
